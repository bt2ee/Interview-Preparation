首先非完整渲染的长列表一般有两种方式：懒渲染以及可视区域渲染。

懒渲染就是大家平常说的无限滚动，指的就是在滚动到页面底部的时候，再去加载剩余的数据，是一种前后端共同优化的方式，后端一次加载比较少的数据可以节省流量，前端首次渲染更少的数据速度会更快，这种优化要求产品方必须接受这种形式的列表，否则就无法使用这种方式优化。

实现的思路非常简单：监听父元素的scroll事件（一般是window），通过父元素的 scrollTop 判断是否到了页面底部，如果到了页面底部，就加载更多的数据。如果要应用在生产上，建议使用成熟的类库，可以通过“框架名+ infinite scroll”来进行搜索。
可视区域渲染指的是只渲染可视区域的列表项目，非可见区域的完全不渲染，在滚动条滚动时动态更新列表项。可视区域渲染适合下面这种场景：

每个数据的展现形式的高度需要一致（非必须，但是最小高度需要确定）。
产品设计上，一次需要加载的数据量比较大（1000条以上），滚动条需要挂载在一个固定高度的区域（在windows 上也可以，但是需要整个区域都只显示这个列表）。

可见区域渲染列表的方式一般叫做 Virtual List，即虚拟列表。什么是虚拟列表？先对虚拟列表做一个简单的定义。因为 Dom 元素的创建和渲染需要的时间成本很高，在大数据的情况下，完整渲染列表所需要的时间不可接受。其中一个解决思路就是在任何情况下只对可见区域进行渲染，可以达到极高的初次渲染性能。虚拟列表指的就是可视区域渲染的列表，重要的基本就是两个概念：

可滚动区域：假设有1000条数据，每个列表项的高度是30，那么可滚动的区域的高度就是1000*30。当用户改变列表的滚动条的当前滚动值的时候会造成可见区域的内容的变更。
可见区域：比如列表的高度是300，右侧有纵向的滚动条可以滚动，那么视觉可见的区域就是可见区域。

实现虚拟列表就是处理滚动条滚动后的可见区域的变更，其中具体的步骤如下：

- 计算当前可见区域起始数据的startIndex；
- 计算当前可见区域结束数据的endIndex；
- 计算当前可见区域的数据，并渲染到页面中；
- 计算startIndex对应的数据在整个列表中的偏移位置startOffset，并设置到列表上


https://zhuanlan.zhihu.com/p/26022258
