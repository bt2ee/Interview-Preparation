对于我最XXXX的项目，是在公司去负责重构最大的运营中台系统并在整个公司落地和推广微服务框架，当时手上的项目过于庞大，很多模块是可以独立存在甚至独立成系统的，外加上项目的设计有问题，比如每个角色首页基本类似却用了多个相同页面，导致迭代的成本过高，甚至说基本处于没办法很好迭代的情况下我们选择了重构。

由于公司本身是没有微服务的落地经验，所以我们拿出项目中一个新的模块进行尝试，然后发现 qiankun 在公司落地可行，于是我们就开始计划重构整个项目，并且考虑到后期对于其他中台系统的接入。对于项目改造我们分成了新旧项目改造两部分。

最初对于**新项目**，我们通过在主应用中配置映射表，配置路由、环境、和侧边栏菜单以及高亮，每一次修改删除路由或者新应用都需要去配置主应用文件，导致子应用发版的同时主应用需要同步发版，特别不方便。
后来配合后端开了一个新的系统应用专门来管理此部分内容，通过系统应用来控制所有的子应用的配置，包括权限，角色，路由等，每一次发版只需要提交一个 issue 给配置人员进行配置即可，主应用不需要在进行同步发版，卸载应用也只需要从系统应用中删除相关的配置即可。

对于**旧项目的改造**只有一个限制，就是尽量最小的改动旧项目。
**不需要重构的旧项目**。在初期我们考虑过将旧项目路由接入主应用，但是涉及到很多问题，比如各个系统样式不统一，接入的时候对子项目侵犯太大，便放弃了这个想法，选择通过主应用去开放入口，新开 tab 页面的方式进入，和其他子应用共用一套权限系统，改造旧项目的登录和路由接口，也能够通过配置的方式去处理旧项目的相关路由
**需要重构的旧项目**。对于需要重构的旧项目，比如我负责重构的运营部门项目，我们选择主应用开放项目入口，新开 tab 页面的方式进入，不和主应用共用一套权限系统，然后在维护的同时完成对旧项目的重构

然后就涉及到一些其他问题。比如**模块拆分**，通过对旧项目的逻辑梳理，梳理出所有相关的接口和模块，通过和产品讨论出哪些部分需要独立成子应用，哪些部分和其他系统模块重复可以合并，得出最终需要重构的模块。对于**模块间的耦合问题**，需要拆分公共组件方法，
**公共依赖组件**也需要拆分发包

**对于页面优化问题**，我们抛弃了原有项目的 class component 模板，全部使用 functional component 进行逻辑处理，引入 useCallback、useMemo、memo 来处理缓存，比如我们原来有一个排期甘特图页面，每次月底期数多达 2000+ ，在旧项目中每次渲染都需要 20s+，我们重新思考整个页面的逻辑，在保留页面必要数据呈现的情况下，将重要性较低的数据隐藏，通过 use-immer 来解决深层数据问题， IntersectionObserver api 进行懒加载，mome 缓存期数卡片，useCallback 缓存计算布局函数等，通过更加合理的方式去渲染和呈现。将页面提速至 2s+。比如我们有些下拉选择项多达上千条，严重影响项目的体验，我们通过虚拟列表去处理这部分的逻辑，让页面更加流畅。

**对于 401， 403 页面的问题**，删除原有应用的权限页面，统一放入主应用中。通过 CustomEvent 去创建事件， 在父应用中监听事件 window.addEventListen('XXX'，method)，在子应用中通过 window.dispatchEvent 触发子应用捕获的错误问题。
这样，我们只需要将 window.dispatchEvent 放入子应用模版项目中即可，无需再做其他处理。

**对于样式泄漏的问题**，由于我们没有开严格沙盒，子应用泄漏了全局样式，比如 ant 的弹窗遮罩
给主应用中的 antd 添加前缀，通过 less-loader 添加 @ant-prefix， 添加 prefixCls 前缀。大部分情况下，我们还是只会在主应用控制菜单和权限，保持主应用与具体业务脱离的原则。

#### 可能被问到的问题
- 你能讲讲虚拟列表是怎么做的吗
- 引入了 ahooks，你们有自定义 hook 吗
- 为什么不用 qiankun 自带的 globalstate
（没有使用 globalstate 是因为我们希望对子应用接入影响最小。）
