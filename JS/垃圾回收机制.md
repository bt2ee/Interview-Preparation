### 原始类型和引用类型
原始类型数据放在栈中，引用类型数据放在堆中。

#### 引用计数垃圾收集
- 跟踪每一个值被引用的次数
如果是零引用就会被回收

> 局限性在于循环饮用水不会被回收。

### 新生代和老生代
![image](https://user-images.githubusercontent.com/32665965/127345760-8cb58cbc-53ff-4522-be8e-c2000a943174.png)

#### 新生代 - 副垃圾回收器(Scavenge算法)
新生区主要存放内存占用小、对象存活时间短的对象。扫描频率更高一些。
- 依次对对象区域中的垃圾做标记
- 将存活的对象复制到空闲区域中
- 清空对象区域
- 将原来的空闲区域变成了对象区域

标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍；空闲区域里此时是有序的，没有碎片，也就不需要整理了。

> 因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。

#### 老生代 - 主垃圾回收器
老生区占用大多数内存，同时也存放那些占用空间大、对象存活时间长的对象。

主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的：
- 遍历堆中的所有对象, 给它们做上标记;
- 能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据，对于代码环境中使用的变量和被强引用的变量取消标记(被标记的都是垃圾);
- 清除垃圾数据，整理磁盘内存
- 标记 - 整理（Mark-Compact）算法，让所有存活的对象都向内存的一端移动，清理掉边界外的内村

**增量标记（Incremental Marking）算法**
将清理全过程拆解为一个一个的小任务，避免造成页面卡顿、阻塞的情况。

#### 对象晋升策略
一个对象是分给新生代还是老生代？划分依据为占用内存大小和存活时间

一个比较小的对象初始化被分到新生代。如果经过两次垃圾回收还依然存活，就会移动到老生代种存储
