### react事件系统原理
#### 事件绑定在哪里？
- 我们在 jsx 中绑定的事件，绑定在了 document 上
- 真实 dom 中的事件背单独处理替换成了空函数
- 我们在 react 上绑定的事件，比如 onChange，在 document 上可能有多个事件与之对应
- react 并不是一开始，就把所有的事件绑定在了 document 上，而是采取的按需绑定，比如发现了 onClick，再去绑定

#### react 事件合成
在 react 中，我们绑定的事件并不是原生事件，而是原生事件合成的 React 事件，比如：click 事件合称为 onClick 事件

#### 为什么要做事件合成
- 将事件绑定在 document 上统一管理，防止很多事件直接绑定在原生 dom 上，防止不可控的情况
- React 想实现一个全浏览器的框架，需要提供全浏览器一致性的事件系统，抹平浏览器差异

#### 事件如何绑定
- react 通过不同的事件名称，找到对应的事件插件，统一绑定在 document 上，没有出现过的事件，就不会绑定
- 每个插件是一个对象，保存了原生事件和合成事件对应的映射关系，大部分事件按照冒泡逻辑处理，少部分按照捕获逻辑处理（scroll、focus、blur）
- react 发现是合成事件后就会注册事件监听器

#### 事件触发
- 通过统一的处理函数，进行批量更新
- 执行事件对应的处理插件，合成事件源对象，通过遍历形成事件执行队列，模拟事件捕获-> 事件源 -> 事件冒泡这一过程
- 执行完后放回事件池中，完成整个流程。

#### React怎么样通过原生的dom元素，找到对应的fiber的呢？
找到当前传入 dom 对应最近的元素类型 fiber 对象。通过 fiber 对象的 stateNode 找到当前 dom 元素

#### 事件池
react 采取事件池的概念，每次使用的事件源对象，在函数执行之后会被释放到事件池中，这样就不用每次都创建事件源对象。

```js
 handerClick = (e) => {
    console.log(e.target) // button
    setTimeout(()=>{
        console.log(e.target) // null
    },0)
}
```

### 事件插件
react 有事件插件记录不同的事件映射，也有 react 事件和原生事件的对应关系，不同的事件有不同的处理逻辑，对应的事件源对象也不同，react 事件源和事件都是自己合成的，所以对于不同的事件需要不同的时间插件处理。

### 问题（基于 v16）
#### 我们写的事件是绑定在dom上么，如果不是绑定在哪里？
我们在 jsx 中绑定的事件，绑定在了 document 上

#### 为什么我们的事件不能绑定给组件？
抹平浏览器差异，避免垃圾回收，方便事件统一管理和事物机制

#### 为什么我们的事件手动绑定this(不是箭头函数的情况)
this 会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到方法而报错。

#### 为什么不能用 return false 来阻止事件的默认行为？
react 中是通过 `isPropagationStopped` 来判断是否阻止冒泡，调用 `e.stopPropagation` 就会返回 `isPropagationStopped=()=>true`，再次调用 `e.isPropagationStopped()` 就会返回 true。就不会再执行了。

#### react怎么通过dom元素，找到与之对应的 fiber对象的？
找到当前传入 dom 对应最近的元素类型 fiber 对象。通过 fiber 对象的 stateNode 找到当前 dom 元素

#### onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？
否，先触发原生事件 冒泡到 document 上的时候 处理 react 事件，然后最后处理 document 上绑定的真实事件

### v17 事件系统
- 统一绑定在 container 上而不是 document 上，利于微前端多个应用的场景
- 对齐原生浏览器事件，onScroll 事件不再进行事件冒泡，onFocus、onBlur 通过原生事件合成
- 取消事件池复用，不会在出现 setTimeout 中找不到 e.target 的问题

#### 为什么取消事件池
在 react 16及之前，复用不同事件的事件对象，并在放入事件池之前将属性设置为 null，需要使用 `e.persist()` 才能用异步的方式使用事件 e，对于现代浏览器来说不需要以此来提高性能并且这样会使开发者困扰。

### 事件流
当一个节点产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为 DOM 事件流。

#### DOM 2 级事件流包括下面几个阶段

- 事件捕获阶段
- 处于目标阶段
- 事件冒泡阶段
事件冒泡：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发（当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 click 事件就触发父元素的 click）。
事件捕获：和冒泡相反，会从上层传递到下层。

#### 阻止冒泡
event.stopPropagation()
